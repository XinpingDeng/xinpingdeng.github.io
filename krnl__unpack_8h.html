<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gxcorr: /data/BALDR_1/den15c/gxcorr/gxcorr/krnl_unpack.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gxcorr
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_61fa3639f67dbf40431b13d81e35ca34.html">gxcorr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">krnl_unpack.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &quot;<a class="el" href="gxcorr__utils_8h_source.html">gxcorr_utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gxcorr__constants_8h_source.html">gxcorr_constants.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for krnl_unpack.h:</div>
<div class="dyncontent">
<div class="center"><img src="krnl__unpack_8h__incl.png" border="0" usemap="#a_2data_2BALDR__1_2den15c_2gxcorr_2gxcorr_2krnl__unpack_8h" alt=""/></div>
<map name="a_2data_2BALDR__1_2den15c_2gxcorr_2gxcorr_2krnl__unpack_8h" id="a_2data_2BALDR__1_2den15c_2gxcorr_2gxcorr_2krnl__unpack_8h">
<area shape="rect" title=" " alt="" coords="68,5,275,47"/>
<area shape="rect" title=" " alt="" coords="5,95,92,121"/>
<area shape="rect" href="gxcorr__utils_8h.html" title=" " alt="" coords="116,95,227,121"/>
<area shape="rect" href="gxcorr__constants_8h.html" title=" " alt="" coords="251,95,396,121"/>
<area shape="rect" title=" " alt="" coords="118,169,225,196"/>
</map>
</div>
</div>
<p><a href="krnl__unpack_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8b092f1ff6993086ef2e32a8fccde801"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="krnl__unpack_8h.html#a8b092f1ff6993086ef2e32a8fccde801">NWARP</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a8b092f1ff6993086ef2e32a8fccde801"><td class="mdescLeft">&#160;</td><td class="mdescRight">A overloaded template kernel to.  <a href="krnl__unpack_8h.html#a8b092f1ff6993086ef2e32a8fccde801">More...</a><br /></td></tr>
<tr class="separator:a8b092f1ff6993086ef2e32a8fccde801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea0293fb7dcba88f071c44fd145819e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="krnl__unpack_8h.html#a9ea0293fb7dcba88f071c44fd145819e">WARP_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a9ea0293fb7dcba88f071c44fd145819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab0ca8edba674814b7028c4e053de9b74"><td class="memTemplParams" colspan="2">template&lt;typename TIN , typename TOUT &gt; </td></tr>
<tr class="memitem:ab0ca8edba674814b7028c4e053de9b74"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="krnl__unpack_8h.html#ab0ca8edba674814b7028c4e053de9b74">krnl_unpack</a> (int nchan, TOUT *dest, const TIN *input)</td></tr>
<tr class="memdesc:ab0ca8edba674814b7028c4e053de9b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">A overloaded template kernel to unpack BIGCAT data from 8-bits or 16-bits data for multiple antennas and 2 polarisations.  <a href="krnl__unpack_8h.html#ab0ca8edba674814b7028c4e053de9b74">More...</a><br /></td></tr>
<tr class="separator:ab0ca8edba674814b7028c4e053de9b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56891e687d89564358ac3e65c9adf60d"><td class="memTemplParams" colspan="2">template&lt;typename TIN , typename TOUT &gt; </td></tr>
<tr class="memitem:a56891e687d89564358ac3e65c9adf60d"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="krnl__unpack_8h.html#a56891e687d89564358ac3e65c9adf60d">krnl_unpack</a> (int nfft, int nchan, TOUT *dest, const float *window, const TIN *input, const float *phase_rotation, const int *shifts, const int ntime_extra)</td></tr>
<tr class="separator:a56891e687d89564358ac3e65c9adf60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af047276aed2a6826f1ebefd6d93550f7"><td class="memTemplParams" colspan="2">template&lt;typename TIN , typename TOUT &gt; </td></tr>
<tr class="memitem:af047276aed2a6826f1ebefd6d93550f7"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="krnl__unpack_8h.html#af047276aed2a6826f1ebefd6d93550f7">krnl_unpack</a> (int nchan, TOUT *dest, const float *window, const TIN *input, const float *phase_rotation, const int *shifts, const int ntime_extra)</td></tr>
<tr class="memdesc:af047276aed2a6826f1ebefd6d93550f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A overloaded template kernel to.  <a href="krnl__unpack_8h.html#af047276aed2a6826f1ebefd6d93550f7">More...</a><br /></td></tr>
<tr class="separator:af047276aed2a6826f1ebefd6d93550f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2beae8983b819f31ae701ac2019d6a7c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2beae8983b819f31ae701ac2019d6a7c"><td class="memTemplItemLeft" align="right" valign="top">__global__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="krnl__unpack_8h.html#a2beae8983b819f31ae701ac2019d6a7c">krnl_unpack</a> (const int8_t *input, T *output, int ntime)</td></tr>
<tr class="separator:a2beae8983b819f31ae701ac2019d6a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8b092f1ff6993086ef2e32a8fccde801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b092f1ff6993086ef2e32a8fccde801">&#9670;&nbsp;</a></span>NWARP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NWARP&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A overloaded template kernel to. </p>
<ol type="1">
<li>unpack BIGCAT data from 8-bits or 16-bits data for multiple antennas and 2 polarisations.</li>
<li>apply delay correction with integer number of samples</li>
<li>phase roration correction in time domain</li>
<li>apply window function to unpacked data</li>
</ol>
<p>To enable sample delay correction with integer number of samples, we record extra samples at each end of time axis. For now we assume that the number of extra time stamps are the same at both end. The kernel actually works with ntime (nfft*nchan) + 2*ntime_extra time stamps, where ntime_extra is number of extra samples at one side</p>
<p>The kernel also assumes antenna which receives signal first has negative delay.</p>
<p>chan_shifted in this kernel currently assume that we are at odd nyquist zones, otherwise we need to update it as chan_shifted = nchan-1-chan_shifted</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="krnl__delay_8h.html#a5028b384cca687236478236faf2bd885" title="CUDA implementation to get delay corrections.">krnl_delay</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIN</td><td>Input raw data type, it is a scalar data type with data width of input complex data components. </td></tr>
    <tr><td class="paramname">TOUT</td><td>Unpacked data type, it should be a complex data type.</td></tr>
  </table>
  </dd>
</dl>
<p>For now the kernel support following data type combinations</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">TIN   </th><th class="markdownTableHeadNone">TOUT    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">short2   </td><td class="markdownTableBodyNone">float2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">short2   </td><td class="markdownTableBodyNone">half2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char2   </td><td class="markdownTableBodyNone">float2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">char2   </td><td class="markdownTableBodyNone">half2   </td></tr>
</table>
<p>Each BIGCAT CODIF UDP packet has a single polarisation and single frequency channel. The packet is supposed to be 8192 Bytes, we have 4096 time stamps for 8-bits data (2048 for 16-bits data) per UDP packet. The data ingest program is supposed to put packets in a [NANT(6) NPOL(2) NPKT], as each packet has data in [NTIME_PER_PKT(4096/2048) NDIM(2)], the overall data order is [NANT(6) NPOL(2) (4096/2048)*NPKT NDIM(2)]. The output data has a similar order as [NANT(6) NPOL (4096/2048)*NPKT]. We can ignore NDIM(2) in the output data as now we have complex data type. Here NPKT should include extra samples at each end, be aware that extra samples of each end should be able to fit into integer number of packets.</p>
<p>We define number of sample of each antenna and each polarisation as <code>ntime*nchan</code>, where nchan is number of frequency channels and ntime is number of time stamps processed by a single execution of following GPU kernels like cross correlation kernel </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="krnl__cross_8h.html#a3d50b12ea410d3ecc06752b32386c86d" title="CUDA implementation of cross correlation with FFT validation markers and delay corrections.">krnl_cross</a>. Be aware that number of samples here is different from (4096/2048)*NPKT as we have extra samples at each end.</dd></dl>
<p>To setup this kernel on host, blockDim.x and gridDim.x are used to define number of channels <em>nchan</em>, where blockDim.x is number of threads (<em>nthread</em>) per CUDA thread block and gridDim.x is <code>nchan/nthread</code>, gridDim.y is number of FFTs <em>nfft</em> and gridDim.z is number of antennas <em>nant</em> </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Kernel dims   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.z   </td><td class="markdownTableBodyNone">nant    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gridDim.y   </td><td class="markdownTableBodyNone">nfft/NWARP    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.x   </td><td class="markdownTableBodyNone">nchan/WARP_SIZE    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blockDim.y   </td><td class="markdownTableBodyNone">NWARP    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">blockDim.x   </td><td class="markdownTableBodyNone">WARP_SIZE   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Raw data in order [NANT NPOL NPKT] to be unpacked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchan</td><td>Number of channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>Window will be applied, all 1 if we do not want to apply window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase_rotation</td><td>Phase rotation vector in order [NANT NFFT 2] (2 for two numbers, not 2 polarisations), all 0 if we do not want to rotate it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shifts</td><td>Shifts in samples in oder [NANT NFFT], all 0 if we do not want to shift it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntime_extra</td><td>Number of extra time stamps at one side, this should match the setup of udp2db </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Unpacked data in order [NANT NPOL NPKT] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea0293fb7dcba88f071c44fd145819e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea0293fb7dcba88f071c44fd145819e">&#9670;&nbsp;</a></span>WARP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WARP_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2beae8983b819f31ae701ac2019d6a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2beae8983b819f31ae701ac2019d6a7c">&#9670;&nbsp;</a></span>krnl_unpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void krnl_unpack </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af047276aed2a6826f1ebefd6d93550f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af047276aed2a6826f1ebefd6d93550f7">&#9670;&nbsp;</a></span>krnl_unpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIN , typename TOUT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void krnl_unpack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nchan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIN *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>phase_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>shifts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ntime_extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A overloaded template kernel to. </p>
<ol type="1">
<li>unpack BIGCAT data from 8-bits or 16-bits data for multiple antennas and 2 polarisations.</li>
<li>apply delay correction with integer number of samples</li>
<li>phase roration correction in time domain</li>
<li>apply window function to unpacked data</li>
</ol>
<p>To enable sample delay correction with integer number of samples, we record extra samples at each end of time axis. For now we assume that the number of extra time stamps are the same at both end. The kernel actually works with ntime (nfft*nchan) + 2*ntime_extra time stamps, where ntime_extra is number of extra samples at one side</p>
<p>The kernel also assumes antenna which receives signal first has negative delay.</p>
<p>chan_shifted in this kernel currently assume that we are at odd nyquist zones, otherwise we need to update it as chan_shifted = nchan-1-chan_shifted</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="krnl__delay_8h.html#a5028b384cca687236478236faf2bd885" title="CUDA implementation to get delay corrections.">krnl_delay</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIN</td><td>Input raw data type, it is a scalar data type with data width of input complex data components. </td></tr>
    <tr><td class="paramname">TOUT</td><td>Unpacked data type, it should be a complex data type.</td></tr>
  </table>
  </dd>
</dl>
<p>For now the kernel support following data type combinations</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">TIN   </th><th class="markdownTableHeadNone">TOUT    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">short2   </td><td class="markdownTableBodyNone">float2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">short2   </td><td class="markdownTableBodyNone">half2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char2   </td><td class="markdownTableBodyNone">float2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">char2   </td><td class="markdownTableBodyNone">half2   </td></tr>
</table>
<p>Each BIGCAT CODIF UDP packet has a single polarisation and single frequency channel. The packet is supposed to be 8192 Bytes, we have 4096 time stamps for 8-bits data (2048 for 16-bits data) per UDP packet. The data ingest program is supposed to put packets in a [NANT(6) NPOL(2) NPKT], as each packet has data in [NTIME_PER_PKT(4096/2048) NDIM(2)], the overall data order is [NANT(6) NPOL(2) (4096/2048)*NPKT NDIM(2)]. The output data has a similar order as [NANT(6) NPOL (4096/2048)*NPKT]. We can ignore NDIM(2) in the output data as now we have complex data type. Here NPKT should include extra samples at each end, be aware that extra samples of each end should be able to fit into integer number of packets.</p>
<p>We define number of sample of each antenna and each polarisation as <code>ntime*nchan</code>, where nchan is number of frequency channels and ntime is number of time stamps processed by a single execution of following GPU kernels like cross correlation kernel </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="krnl__cross_8h.html#a3d50b12ea410d3ecc06752b32386c86d" title="CUDA implementation of cross correlation with FFT validation markers and delay corrections.">krnl_cross</a>. Be aware that number of samples here is different from (4096/2048)*NPKT as we have extra samples at each end.</dd></dl>
<p>To setup this kernel on host, blockDim.x and gridDim.x are used to define number of channels <em>nchan</em>, where blockDim.x is number of threads (<em>nthread</em>) per CUDA thread block and gridDim.x is <code>nchan/nthread</code>, gridDim.y is number of FFTs <em>nfft</em> and gridDim.z is number of antennas <em>nant</em> </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Kernel dims   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.z   </td><td class="markdownTableBodyNone">nant    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gridDim.y   </td><td class="markdownTableBodyNone">nfft    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.x   </td><td class="markdownTableBodyNone">nchan/nthread    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blockDim.x   </td><td class="markdownTableBodyNone">nthread   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Raw data in order [NANT NPOL NPKT] to be unpacked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchan</td><td>Number of channels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">window</td><td>Window will be applied, all 1 if we do not want to apply window </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase_rotation</td><td>Phase rotation vector in order [NANT NFFT 2] (2 for two numbers, not 2 polarisations), all 0 if we do not want to rotate it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shifts</td><td>Shifts in samples in oder [NANT NFFT], all 0 if we do not want to shift it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ntime_extra</td><td>Number of extra time stamps at one side, this should match the setup of udp2db </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Unpacked data in order [NANT NPOL NPKT] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0ca8edba674814b7028c4e053de9b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ca8edba674814b7028c4e053de9b74">&#9670;&nbsp;</a></span>krnl_unpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIN , typename TOUT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void krnl_unpack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nchan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIN *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A overloaded template kernel to unpack BIGCAT data from 8-bits or 16-bits data for multiple antennas and 2 polarisations. </p>
<p>chan_shifted in this kernel currently assume that we are at odd nyquist zones, otherwise we need to update it as chan_shifted = nchan-1-chan_shifted</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="krnl__delay_8h.html#a5028b384cca687236478236faf2bd885" title="CUDA implementation to get delay corrections.">krnl_delay</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIN</td><td>Input raw data type, it is a scalar data type with data width of input complex data components. </td></tr>
    <tr><td class="paramname">TOUT</td><td>Unpacked data type, it should be a complex data type.</td></tr>
  </table>
  </dd>
</dl>
<p>For now the kernel support following data type combinations</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">TIN   </th><th class="markdownTableHeadNone">TOUT    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">short2   </td><td class="markdownTableBodyNone">float2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">short2   </td><td class="markdownTableBodyNone">half2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char2   </td><td class="markdownTableBodyNone">float2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">char2   </td><td class="markdownTableBodyNone">half2   </td></tr>
</table>
<p>Each BIGCAT CODIF UDP packet has a single polarisation and single frequency channel. The packet is supposed to be 8192 Bytes, we have 4096 time stamps for 8-bits data (2048 for 16-bits data) per UDP packet. The data ingest program is supposed to put packets in a [NANT(6) NPOL(2) NPKT], as each packet has data in [NTIME_PER_PKT(4096/2048) NDIM(2)], the overall data order is [NANT(6) NPOL(2) (4096/2048)*NPKT NDIM(2)]. The output data has a similar order as [NANT(6) NPOL (4096/2048)*NPKT]. We can ignore NDIM(2) in the output data as now we have complex data type. Here NPKT should include extra samples at each end, be aware that extra samples of each end should be able to fit into integer number of packets.</p>
<p>We define number of sample of each antenna and each polarisation as <code>ntime*nchan</code>, where nchan is number of frequency channels and ntime is number of time stamps processed by a single execution of following GPU kernels like cross correlation kernel </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="krnl__cross_8h.html#a3d50b12ea410d3ecc06752b32386c86d" title="CUDA implementation of cross correlation with FFT validation markers and delay corrections.">krnl_cross</a>. Be aware that number of samples here is different from (4096/2048)*NPKT as we have extra samples at each end.</dd></dl>
<p>To setup this kernel on host, blockDim.x and gridDim.x are used to define number of channels <em>nchan</em>, where blockDim.x is number of threads (<em>nthread</em>) per CUDA thread block and gridDim.x is <code>nchan/nthread</code>, gridDim.y is number of FFTs <em>nfft</em> and gridDim.z is number of antennas <em>nant</em> </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Kernel dims   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.z   </td><td class="markdownTableBodyNone">nant    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gridDim.y   </td><td class="markdownTableBodyNone">nfft    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gridDim.x   </td><td class="markdownTableBodyNone">nchan/nthread    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blockDim.x   </td><td class="markdownTableBodyNone">nthread   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Raw data in order [NANT NPOL NPKT] to be unpacked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchan</td><td>Number of channels </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Unpacked data in order [NANT NPOL NPKT] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56891e687d89564358ac3e65c9adf60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56891e687d89564358ac3e65c9adf60d">&#9670;&nbsp;</a></span>krnl_unpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIN , typename TOUT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__global__ void krnl_unpack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nchan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIN *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>phase_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>shifts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ntime_extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
